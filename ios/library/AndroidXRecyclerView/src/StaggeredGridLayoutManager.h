//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\StaggeredGridLayoutManager.java
//

#import <Foundation/Foundation.h>
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_StaggeredGridLayoutManager")
#ifdef RESTRICT_StaggeredGridLayoutManager
#define INCLUDE_ALL_StaggeredGridLayoutManager 0
#else
#define INCLUDE_ALL_StaggeredGridLayoutManager 1
#endif
#undef RESTRICT_StaggeredGridLayoutManager

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADXStaggeredGridLayoutManager_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager))
#define ADXStaggeredGridLayoutManager_

#define RESTRICT_RecyclerView 1
#define INCLUDE_ADXRecyclerView_LayoutManager 1
#include "RecyclerView.h"

@class ADRect;
@class ADView;
@class ADXOrientationHelper;
@class ADXRecyclerView;
@class ADXRecyclerView_Adapter;
@class ADXRecyclerView_LayoutParams;
@class ADXRecyclerView_Recycler;
@class ADXRecyclerView_State;
@class ADXStaggeredGridLayoutManager_AnchorInfo;
@class ADXStaggeredGridLayoutManager_LazySpanLookup;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangInteger;
@class NSString;
@protocol ADParcelable;
@protocol ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry;

/*!
 @brief A LayoutManager that lays out children in a staggered grid formation.
 It supports horizontal & vertical layout as well as an ability to layout children in reverse. 
 <p>
  Staggered grids are likely to have gaps at the edges of the layout. To avoid these gaps,
  StaggeredGridLayoutManager can offset spans independently or move items between spans. You can
  control this behavior via <code>setGapStrategy(int)</code>.
 */
@interface ADXStaggeredGridLayoutManager : ADXRecyclerView_LayoutManager {
 @public
  IOSObjectArray *mSpans_;
  /*!
   @brief Primary orientation is the layout's orientation, secondary orientation is the orientation
  for spans.Having both makes code much cleaner for calculations.
   */
  ADXOrientationHelper *mPrimaryOrientation_;
  ADXOrientationHelper *mSecondaryOrientation_;
  bool mReverseLayout_;
  /*!
   @brief Aggregated reverse layout value that takes RTL into account.
   */
  bool mShouldReverseLayout_;
  /*!
   @brief When LayoutManager needs to scroll to a position, it sets this variable and requests a
  layout which will check this variable and re-layout accordingly.
   */
  int32_t mPendingScrollPosition_;
  /*!
   @brief Used to keep the offset value when <code>scrollToPositionWithOffset(int, int)</code> is
  called.
   */
  int32_t mPendingScrollPositionOffset_;
  /*!
   @brief Keeps the mapping between the adapter positions and spans.This is necessary to provide
  a consistent experience when user scrolls the list.
   */
  ADXStaggeredGridLayoutManager_LazySpanLookup *mLazySpanLookup_;
}

#pragma mark Public

/*!
 @brief Constructor used when layout manager is set in XML by RecyclerView attribute
  "layoutManager".Defaults to single column and vertical.
 */
- (instancetype)initWithInt:(int32_t)spanCount
                    withInt:(int32_t)orientation;

- (void)assertNotInLayoutOrScrollWithNSString:(NSString *)message;

- (bool)canScrollHorizontally;

- (bool)canScrollVertically;

- (bool)checkLayoutParamsWithADXRecyclerView_LayoutParams:(ADXRecyclerView_LayoutParams *)lp;

/*!
 */
- (void)collectAdjacentPrefetchPositionsWithInt:(int32_t)dx
                                        withInt:(int32_t)dy
                      withADXRecyclerView_State:(ADXRecyclerView_State *)state
withADXRecyclerView_LayoutManager_LayoutPrefetchRegistry:(id<ADXRecyclerView_LayoutManager_LayoutPrefetchRegistry>)layoutPrefetchRegistry;

- (int32_t)computeHorizontalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)computeHorizontalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)computeHorizontalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)computeVerticalScrollExtentWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)computeVerticalScrollOffsetWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)computeVerticalScrollRangeWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Returns the adapter position of the first completely visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the first fully visible item in each span. If a span does
  not have any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstVisibleItemPositions(int[])
 - seealso: #findLastCompletelyVisibleItemPositions(int[])
 */
- (IOSIntArray *)findFirstCompletelyVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the first visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the first visible item in each span. If a span does not have
  any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstCompletelyVisibleItemPositions(int[])
 - seealso: #findLastVisibleItemPositions(int[])
 */
- (IOSIntArray *)findFirstVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the last completely visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the last fully visible item in each span. If a span does not
  have any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findFirstCompletelyVisibleItemPositions(int[])
 - seealso: #findLastVisibleItemPositions(int[])
 */
- (IOSIntArray *)findLastCompletelyVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

/*!
 @brief Returns the adapter position of the last visible view for each span.
 <p>
  Note that, this value is not affected by layout orientation or item order traversal.
  (<code>setReverseLayout(boolean)</code>). Views are sorted by their positions in the adapter,
  not in the layout. 
 <p>
  If RecyclerView has item decorators, they will be considered in calculations as well. 
 <p>
  StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
  views are ignored in this method.
 @param into An array to put the results into. If you don't provide any, LayoutManager will              create a new one.
 @return The adapter position of the last visible item in each span. If a span does not have
  any items, <code>RecyclerView.NO_POSITION</code> is returned for that span.
 - seealso: #findLastCompletelyVisibleItemPositions(int[])
 - seealso: #findFirstVisibleItemPositions(int[])
 */
- (IOSIntArray *)findLastVisibleItemPositionsWithIntArray:(IOSIntArray *)into;

- (ADXRecyclerView_LayoutParams *)generateDefaultLayoutParams;

/*!
 @brief Returns the current gap handling strategy for StaggeredGridLayoutManager.
 <p>
  Staggered grid may have gaps in the layout due to changes in the adapter. To avoid gaps,
  StaggeredGridLayoutManager provides 2 options. Check <code>GAP_HANDLING_NONE</code> and 
 <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code> for details. 
 <p>
  By default, StaggeredGridLayoutManager uses <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code>.
 @return Current gap handling strategy.
 - seealso: #setGapStrategy(int)
 - seealso: #GAP_HANDLING_NONE
 - seealso: #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS
 */
- (int32_t)getGapStrategy;

- (int32_t)getOrientation;

/*!
 @brief Returns whether views are laid out in reverse order or not.
 <p>
  Not that this value is not affected by RecyclerView's layout direction.
 @return True if layout is reversed, false otherwise
 - seealso: #setReverseLayout(boolean)
 */
- (bool)getReverseLayout;

/*!
 @brief Returns the number of spans laid out by StaggeredGridLayoutManager.
 @return Number of spans in the layout
 */
- (int32_t)getSpanCount;

/*!
 @brief For consistency, StaggeredGridLayoutManager keeps a mapping between spans and items.
 <p>
  If you need to cancel current assignments, you can call this method which will clear all
  assignments and request a new layout.
 */
- (void)invalidateSpanAssignments;

- (bool)isAutoMeasureEnabled;

- (void)offsetChildrenHorizontalWithInt:(int32_t)dx;

- (void)offsetChildrenVerticalWithInt:(int32_t)dy;

- (void)onAdapterChangedWithADXRecyclerView_Adapter:(ADXRecyclerView_Adapter *)oldAdapter
                        withADXRecyclerView_Adapter:(ADXRecyclerView_Adapter *)newAdapter;

- (void)onDetachedFromWindowWithADXRecyclerView:(ADXRecyclerView *)view
                   withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler;

- (ADView *)onFocusSearchFailedWithADView:(ADView *)focused
                                  withInt:(int32_t)direction
             withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onItemsAddedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                withInt:(int32_t)positionStart
                                withInt:(int32_t)itemCount;

- (void)onItemsChangedWithADXRecyclerView:(ADXRecyclerView *)recyclerView;

- (void)onItemsMovedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                withInt:(int32_t)from
                                withInt:(int32_t)to
                                withInt:(int32_t)itemCount;

- (void)onItemsRemovedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                  withInt:(int32_t)positionStart
                                  withInt:(int32_t)itemCount;

- (void)onItemsUpdatedWithADXRecyclerView:(ADXRecyclerView *)recyclerView
                                  withInt:(int32_t)positionStart
                                  withInt:(int32_t)itemCount
                                   withId:(id)payload;

- (void)onLayoutChildrenWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
                           withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onLayoutCompletedWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)onRestoreInstanceStateWithADParcelable:(id<ADParcelable>)state;

- (id<ADParcelable>)onSaveInstanceState;

- (void)onScrollStateChangedWithInt:(int32_t)state;

- (int32_t)scrollHorizontallyByWithInt:(int32_t)dx
          withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
             withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (void)scrollToPositionWithInt:(int32_t)position;

/*!
 @brief Scroll to the specified adapter position with the given offset from layout start.
 <p>
  Note that scroll position change will not be reflected until the next layout call. 
 <p>
  If you are just trying to make a position visible, use <code>scrollToPosition(int)</code>.
 @param position Index (starting at 0) of the reference item.
 @param offset The distance (in pixels) between the start edge of the item view and                  start edge of the RecyclerView.
 - seealso: #setReverseLayout(boolean)
 - seealso: #scrollToPosition(int)
 */
- (void)scrollToPositionWithOffsetWithInt:(int32_t)position
                                  withInt:(int32_t)offset;

- (int32_t)scrollVerticallyByWithInt:(int32_t)dy
        withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
           withADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Sets the gap handling strategy for StaggeredGridLayoutManager.If the gapStrategy parameter
  is different than the current strategy, calling this method will trigger a layout request.
 @param gapStrategy The new gap handling strategy. Should be                     
 <code>GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS</code>  or <code>GAP_HANDLING_NONE</code>
  .
 - seealso: #getGapStrategy()
 */
- (void)setGapStrategyWithInt:(int32_t)gapStrategy;

- (void)setMeasuredDimensionWithADRect:(ADRect *)childrenBounds
                               withInt:(int32_t)wSpec
                               withInt:(int32_t)hSpec;

/*!
 @brief Sets the orientation of the layout.StaggeredGridLayoutManager will do its best to keep
  scroll position if this method is called after views are laid out.
 @param orientation<code>HORIZONTAL</code>  or <code>VERTICAL</code>
 */
- (void)setOrientationWithInt:(int32_t)orientation;

/*!
 @brief Sets whether LayoutManager should start laying out items from the end of the UI.The order
  items are traversed is not affected by this call.
 <p>
  For vertical layout, if it is set to <code>true</code>, first item will be at the bottom of
  the list. 
 <p>
  For horizontal layouts, it depends on the layout direction.
  When set to true, If <code>RecyclerView</code> is LTR, than it will layout from RTL, if 
 <code>RecyclerView</code>} is RTL, it will layout from LTR.
 @param reverseLayout Whether layout should be in reverse or not
 */
- (void)setReverseLayoutWithBoolean:(bool)reverseLayout;

/*!
 @brief Sets the number of spans for the layout.This will invalidate all of the span assignments
  for Views.
 <p>
  Calling this method will automatically result in a new layout request unless the spanCount
  parameter is equal to current span count.
 @param spanCount Number of spans to layout
 */
- (void)setSpanCountWithInt:(int32_t)spanCount;

- (bool)supportsPredictiveItemAnimations;

#pragma mark Package-Private

- (bool)areAllEndsEqual;

- (bool)areAllStartsEqual;

/*!
 @brief Checks for gaps in the UI that may be caused by adapter changes.
 <p>
  When a full span item is laid out in reverse direction, it sets a flag which we check when
  scroll is stopped (or re-layout happens) and re-layout after first valid item.
 */
- (bool)checkForGaps;

/*!
 @brief This is for internal use.Not necessarily the child closest to bottom but the first child
  we find that matches the criteria.
 This method does not do any sorting based on child's end coordinate, instead, it uses
  children order.
 */
- (ADView *)findFirstVisibleItemClosestToEndWithBoolean:(bool)fullyVisible;

/*!
 @brief This is for internal use.Not necessarily the child closest to start but the first child
  we find that matches the criteria.
 This method does not do any sorting based on child's start coordinate, instead, it uses
  children order.
 */
- (ADView *)findFirstVisibleItemClosestToStartWithBoolean:(bool)fullyVisible;

/*!
 @brief Finds the first fully visible child to be used as an anchor child if span count changes when
  state is restored.If no children is fully visible, returns a partially visible child instead
  of returning null.
 */
- (int32_t)findFirstVisibleItemPositionInt;

- (int32_t)getFirstChildPosition;

- (int32_t)getLastChildPosition;

/*!
 @brief Checks for gaps if we've reached to the top of the list.
 <p>
  Intermediate gaps created by full span items are tracked via mLaidOutInvalidFullSpan field.
 */
- (ADView *)hasGapsToFix;

- (bool)isLayoutRTL;

- (void)prepareLayoutStateForDeltaWithInt:(int32_t)delta
                withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (int32_t)scrollByWithInt:(int32_t)dt
withADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler
 withADXRecyclerView_State:(ADXRecyclerView_State *)state;

- (bool)updateAnchorFromPendingDataWithADXRecyclerView_State:(ADXRecyclerView_State *)state
                withADXStaggeredGridLayoutManager_AnchorInfo:(ADXStaggeredGridLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateAnchorInfoForLayoutWithADXRecyclerView_State:(ADXRecyclerView_State *)state
              withADXStaggeredGridLayoutManager_AnchorInfo:(ADXStaggeredGridLayoutManager_AnchorInfo *)anchorInfo;

- (void)updateMeasureSpecsWithInt:(int32_t)totalSpace;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mSpans_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mPrimaryOrientation_, ADXOrientationHelper *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mSecondaryOrientation_, ADXOrientationHelper *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager, mLazySpanLookup_, ADXStaggeredGridLayoutManager_LazySpanLookup *)

inline bool ADXStaggeredGridLayoutManager_get_DEBUG(void);
#define ADXStaggeredGridLayoutManager_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, DEBUG, bool)

inline int32_t ADXStaggeredGridLayoutManager_get_HORIZONTAL(void);
#define ADXStaggeredGridLayoutManager_HORIZONTAL 0
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, HORIZONTAL, int32_t)

inline int32_t ADXStaggeredGridLayoutManager_get_VERTICAL(void);
#define ADXStaggeredGridLayoutManager_VERTICAL 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, VERTICAL, int32_t)

/*!
 @brief Does not do anything to hide gaps.
 */
inline int32_t ADXStaggeredGridLayoutManager_get_GAP_HANDLING_NONE(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_NONE, int32_t)

/*!
 */
inline int32_t ADXStaggeredGridLayoutManager_get_GAP_HANDLING_LAZY(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_LAZY 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_LAZY, int32_t)

/*!
 @brief When scroll state is changed to <code>RecyclerView.SCROLL_STATE_IDLE</code>, StaggeredGrid will
  check if there are gaps in the because of full span items.If it finds, it will re-layout
  and move items to correct positions with animations.
 <p>
  For example, if LayoutManager ends up with the following layout due to adapter changes: 
 @code

  AAA
  _BC
  DDD 
  
@endcode
  <p>
  It will animate to the following state: 
 @code

  AAA
  BC_
  DDD 
  
@endcode
 */
inline int32_t ADXStaggeredGridLayoutManager_get_GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS(void);
#define ADXStaggeredGridLayoutManager_GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS 2
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS, int32_t)

inline int32_t ADXStaggeredGridLayoutManager_get_INVALID_OFFSET(void);
#define ADXStaggeredGridLayoutManager_INVALID_OFFSET ((int32_t) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager, INVALID_OFFSET, int32_t)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_initWithInt_withInt_(ADXStaggeredGridLayoutManager *self, int32_t spanCount, int32_t orientation);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager *new_ADXStaggeredGridLayoutManager_initWithInt_withInt_(int32_t spanCount, int32_t orientation) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager *create_ADXStaggeredGridLayoutManager_initWithInt_withInt_(int32_t spanCount, int32_t orientation);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager)

@compatibility_alias AndroidxRecyclerviewWidgetStaggeredGridLayoutManager ADXStaggeredGridLayoutManager;


#endif

#if !defined (ADXStaggeredGridLayoutManager_LayoutParams_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LayoutParams))
#define ADXStaggeredGridLayoutManager_LayoutParams_

#define RESTRICT_RecyclerView 1
#define INCLUDE_ADXRecyclerView_LayoutParams 1
#include "RecyclerView.h"

@class ADViewGroup_LayoutParams;
@class ADViewGroup_MarginLayoutParams;
@class ADXStaggeredGridLayoutManager_Span;
@class JavaLangBoolean;
@class JavaLangInteger;

/*!
 @brief LayoutParams used by StaggeredGridLayoutManager.
 <p>
  Note that if the orientation is <code>VERTICAL</code>, the width parameter is ignored and if the
  orientation is <code>HORIZONTAL</code> the height parameter is ignored because child view is
  expected to fill all of the space given to it.
 */
@interface ADXStaggeredGridLayoutManager_LayoutParams : ADXRecyclerView_LayoutParams {
 @public
  ADXStaggeredGridLayoutManager_Span *mSpan_;
  bool mFullSpan_;
}

#pragma mark Public

/*!
 */
- (instancetype)initWithInt:(int32_t)width
                    withInt:(int32_t)height;

- (instancetype)initWithADViewGroup_LayoutParams:(ADViewGroup_LayoutParams *)source;

- (instancetype)initWithADXRecyclerView_LayoutParams:(ADXRecyclerView_LayoutParams *)source;

- (instancetype)initWithADViewGroup_MarginLayoutParams:(ADViewGroup_MarginLayoutParams *)source;

/*!
 @brief Returns the Span index to which this View is assigned.
 @return The Span index of the View. If View is not yet assigned to any span, returns 
 <code>INVALID_SPAN_ID</code>.
 */
- (int32_t)getSpanIndex;

/*!
 @brief Returns whether this View occupies all available spans or just one.
 @return True if the View occupies all spans or false otherwise.
 - seealso: #setFullSpan(boolean)
 */
- (bool)isFullSpan;

/*!
 @brief When set to true, the item will layout using all span area.That means, if orientation
  is vertical, the view will have full width; if orientation is horizontal, the view will
  have full height.
 @param fullSpan True if this item should traverse all spans.
 - seealso: #isFullSpan()
 */
- (void)setFullSpanWithBoolean:(bool)fullSpan;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LayoutParams)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LayoutParams, mSpan_, ADXStaggeredGridLayoutManager_Span *)

/*!
 @brief Span Id for Views that are not laid out yet.
 */
inline int32_t ADXStaggeredGridLayoutManager_LayoutParams_get_INVALID_SPAN_ID(void);
#define ADXStaggeredGridLayoutManager_LayoutParams_INVALID_SPAN_ID -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager_LayoutParams, INVALID_SPAN_ID, int32_t)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(ADXStaggeredGridLayoutManager_LayoutParams *self, int32_t width, int32_t height);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(int32_t width, int32_t height) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithInt_withInt_(int32_t width, int32_t height);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADViewGroup_MarginLayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADViewGroup_MarginLayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_MarginLayoutParams_(ADViewGroup_MarginLayoutParams *source);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADViewGroup_LayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADViewGroup_LayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADViewGroup_LayoutParams_(ADViewGroup_LayoutParams *source);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXStaggeredGridLayoutManager_LayoutParams *self, ADXRecyclerView_LayoutParams *source);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *new_ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXRecyclerView_LayoutParams *source) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LayoutParams *create_ADXStaggeredGridLayoutManager_LayoutParams_initWithADXRecyclerView_LayoutParams_(ADXRecyclerView_LayoutParams *source);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LayoutParams)


#endif

#if !defined (ADXStaggeredGridLayoutManager_Span_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_Span))
#define ADXStaggeredGridLayoutManager_Span_

@class ADView;
@class ADXStaggeredGridLayoutManager;
@class ADXStaggeredGridLayoutManager_LayoutParams;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaUtilArrayList;

@interface ADXStaggeredGridLayoutManager_Span : NSObject {
 @public
  JavaUtilArrayList *mViews_;
  int32_t mCachedStart_;
  int32_t mCachedEnd_;
  int32_t mDeletedSize_;
  int32_t mIndex_;
}

#pragma mark Public

- (int32_t)findFirstCompletelyVisibleItemPosition;

- (int32_t)findFirstPartiallyVisibleItemPosition;

- (int32_t)findFirstVisibleItemPosition;

- (int32_t)findLastCompletelyVisibleItemPosition;

- (int32_t)findLastPartiallyVisibleItemPosition;

- (int32_t)findLastVisibleItemPosition;

- (int32_t)getDeletedSize;

/*!
 @brief Depending on the layout direction, returns the View that is after the given position.
 */
- (ADView *)getFocusableViewAfterWithInt:(int32_t)referenceChildPosition
                                 withInt:(int32_t)layoutDir;

#pragma mark Package-Private

- (instancetype)initWithADXStaggeredGridLayoutManager:(ADXStaggeredGridLayoutManager *)outer$
                                              withInt:(int32_t)index;

- (void)appendToSpanWithADView:(ADView *)view;

- (void)cacheReferenceLineAndClearWithBoolean:(bool)reverseLayout
                                      withInt:(int32_t)offset;

- (void)calculateCachedEnd;

- (void)calculateCachedStart;

- (void)clear;

/*!
 @brief Returns the first view within this span that is partially or fully visible.Partially
  visible refers to a view that overlaps but is not fully contained within RV's padded
  bounded area.
 This view returned can be defined to have an area of overlap strictly
  greater than zero if acceptEndPointInclusion is false. If true, the view's endpoint
  inclusion is enough to consider it partially visible. The latter case can then refer to
  an out-of-bounds view positioned right at the top (or bottom) boundaries of RV's padded
  area. This is used e.g. inside 
 <code>onFocusSearchFailed(View, int, RecyclerView.Recycler, RecyclerView.State)</code> for
  calculating the next unfocusable child to become visible on the screen.
 @param fromIndex The child position index to start the search from.
 @param toIndex The child position index to end the search at.
 @param completelyVisible True if we have to only consider completely visible views,                           false otherwise.
 @param acceptCompletelyVisible True if we can consider both partially or fully visible                                 views, false, if only a partially visible child should be
                                  returned.
 @param acceptEndPointInclusion If the view's endpoint intersection with RV's padded                                 bounded area is enough to consider it partially visible,
                                  false otherwise
 @return The adapter position of the first view that's either partially or fully visible. 
 <code>RecyclerView.NO_POSITION</code> if no such view is found.
 */
- (int32_t)findOnePartiallyOrCompletelyVisibleChildWithInt:(int32_t)fromIndex
                                                   withInt:(int32_t)toIndex
                                               withBoolean:(bool)completelyVisible
                                               withBoolean:(bool)acceptCompletelyVisible
                                               withBoolean:(bool)acceptEndPointInclusion;

- (int32_t)findOnePartiallyVisibleChildWithInt:(int32_t)fromIndex
                                       withInt:(int32_t)toIndex
                                   withBoolean:(bool)acceptEndPointInclusion;

- (int32_t)findOneVisibleChildWithInt:(int32_t)fromIndex
                              withInt:(int32_t)toIndex
                          withBoolean:(bool)completelyVisible;

- (int32_t)getEndLine;

- (int32_t)getEndLineWithInt:(int32_t)def;

- (ADXStaggeredGridLayoutManager_LayoutParams *)getLayoutParamsWithADView:(ADView *)view;

- (int32_t)getStartLine;

- (int32_t)getStartLineWithInt:(int32_t)def;

- (void)invalidateCache;

- (void)onOffsetWithInt:(int32_t)dt;

- (void)popEnd;

- (void)popStart;

- (void)prependToSpanWithADView:(ADView *)view;

- (void)setLineWithInt:(int32_t)line;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_Span)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_Span, mViews_, JavaUtilArrayList *)

inline int32_t ADXStaggeredGridLayoutManager_Span_get_INVALID_LINE(void);
#define ADXStaggeredGridLayoutManager_Span_INVALID_LINE ((int32_t) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXStaggeredGridLayoutManager_Span, INVALID_LINE, int32_t)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager_Span *self, ADXStaggeredGridLayoutManager *outer$, int32_t index);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_Span *new_ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager *outer$, int32_t index) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_Span *create_ADXStaggeredGridLayoutManager_Span_initWithADXStaggeredGridLayoutManager_withInt_(ADXStaggeredGridLayoutManager *outer$, int32_t index);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_Span)


#endif

#if !defined (ADXStaggeredGridLayoutManager_LazySpanLookup_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LazySpanLookup))
#define ADXStaggeredGridLayoutManager_LazySpanLookup_

@class ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem;
@class ADXStaggeredGridLayoutManager_Span;
@class IOSIntArray;
@class JavaLangBoolean;
@class JavaLangInteger;
@protocol JavaUtilList;

/*!
 @brief An array of mappings from adapter position to span.
 This only grows when a write happens and it grows up to the size of the adapter.
 */
@interface ADXStaggeredGridLayoutManager_LazySpanLookup : NSObject {
 @public
  IOSIntArray *mData_;
  id<JavaUtilList> mFullSpanItems_;
}

#pragma mark Public

- (void)addFullSpanItemWithADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem:(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)fullSpanItem;

/*!
 @param minPos inclusive
 @param maxPos exclusive
 @param gapDir if not 0, returns FSIs on in that direction
 @param hasUnwantedGapAfter If true, when full span item has unwanted gaps, it will be                         returned even if its gap direction does not match.
 */
- (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)getFirstFullSpanItemInRangeWithInt:(int32_t)minPos
                                                                                          withInt:(int32_t)maxPos
                                                                                          withInt:(int32_t)gapDir
                                                                                      withBoolean:(bool)hasUnwantedGapAfter;

- (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *)getFullSpanItemWithInt:(int32_t)position;

#pragma mark Package-Private

- (instancetype)init;

- (void)clear;

- (void)ensureSizeWithInt:(int32_t)position;

/*!
 @brief Invalidates everything after this position, including full span information
 */
- (int32_t)forceInvalidateAfterWithInt:(int32_t)position;

- (int32_t)getSpanWithInt:(int32_t)position;

/*!
 @brief returns end position for invalidation.
 */
- (int32_t)invalidateAfterWithInt:(int32_t)position;

- (void)offsetForAdditionWithInt:(int32_t)positionStart
                         withInt:(int32_t)itemCount;

- (void)offsetForRemovalWithInt:(int32_t)positionStart
                        withInt:(int32_t)itemCount;

- (void)setSpanWithInt:(int32_t)position
withADXStaggeredGridLayoutManager_Span:(ADXStaggeredGridLayoutManager_Span *)span;

- (int32_t)sizeForPositionWithInt:(int32_t)position;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LazySpanLookup)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup, mData_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup, mFullSpanItems_, id<JavaUtilList>)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_init(ADXStaggeredGridLayoutManager_LazySpanLookup *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup *new_ADXStaggeredGridLayoutManager_LazySpanLookup_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup *create_ADXStaggeredGridLayoutManager_LazySpanLookup_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LazySpanLookup)


#endif

#if !defined (ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem))
#define ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_

#define RESTRICT_Parcelable 1
#define INCLUDE_ADParcelable 1
#include "Parcelable.h"

@class IOSIntArray;
@class JavaLangBoolean;
@class JavaLangInteger;
@class NSString;
@protocol ADParcel;

/*!
 @brief We keep information about full span items because they may create gaps in the UI.
 */
@interface ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem : NSObject < ADParcelable > {
 @public
  int32_t mPosition_;
  int32_t mGapDir_;
  IOSIntArray *mGapPerSpan_;
  bool mHasUnwantedGapAfter_;
}

#pragma mark Public

- (int32_t)describeContents;

- (NSString *)description;

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(int32_t)flags;

#pragma mark Package-Private

- (instancetype)init;

- (instancetype)initWithADParcel:(id<ADParcel>)inArg;

- (int32_t)getGapForSpanWithInt:(int32_t)spanIndex;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem, mGapPerSpan_, IOSIntArray *)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *self, id<ADParcel> inArg);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *new_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(id<ADParcel> inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *create_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_initWithADParcel_(id<ADParcel> inArg);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *new_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem *create_ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_LazySpanLookup_FullSpanItem)


#endif

#if !defined (ADXStaggeredGridLayoutManager_SavedState_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_SavedState))
#define ADXStaggeredGridLayoutManager_SavedState_

#define RESTRICT_Parcelable 1
#define INCLUDE_ADParcelable 1
#include "Parcelable.h"

@class IOSIntArray;
@class JavaLangBoolean;
@class JavaLangInteger;
@protocol ADParcel;
@protocol JavaUtilList;

/*!
 */
@interface ADXStaggeredGridLayoutManager_SavedState : NSObject < ADParcelable > {
 @public
  int32_t mAnchorPosition_;
  int32_t mVisibleAnchorPosition_;
  int32_t mSpanOffsetsSize_;
  IOSIntArray *mSpanOffsets_;
  int32_t mSpanLookupSize_;
  IOSIntArray *mSpanLookup_;
  id<JavaUtilList> mFullSpanItems_;
  bool mReverseLayout_;
  bool mAnchorLayoutFromEnd_;
  bool mLastLayoutRTL_;
}

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithADXStaggeredGridLayoutManager_SavedState:(ADXStaggeredGridLayoutManager_SavedState *)other;

- (int32_t)describeContents;

- (void)writeToParcelWithADParcel:(id<ADParcel>)dest
                          withInt:(int32_t)flags;

#pragma mark Package-Private

- (instancetype)initWithADParcel:(id<ADParcel>)inArg;

- (void)invalidateAnchorPositionInfo;

- (void)invalidateSpanInfo;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_SavedState)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mSpanOffsets_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mSpanLookup_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_SavedState, mFullSpanItems_, id<JavaUtilList>)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_init(ADXStaggeredGridLayoutManager_SavedState *self);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_init(void);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(ADXStaggeredGridLayoutManager_SavedState *self, id<ADParcel> inArg);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_initWithADParcel_(id<ADParcel> inArg);

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *self, ADXStaggeredGridLayoutManager_SavedState *other);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *new_ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *other) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_SavedState *create_ADXStaggeredGridLayoutManager_SavedState_initWithADXStaggeredGridLayoutManager_SavedState_(ADXStaggeredGridLayoutManager_SavedState *other);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_SavedState)


#endif

#if !defined (ADXStaggeredGridLayoutManager_AnchorInfo_) && (INCLUDE_ALL_StaggeredGridLayoutManager || defined(INCLUDE_ADXStaggeredGridLayoutManager_AnchorInfo))
#define ADXStaggeredGridLayoutManager_AnchorInfo_

@class ADXStaggeredGridLayoutManager;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangInteger;

/*!
 @brief Data class to hold the information about an anchor position which is used in onLayout call.
 */
@interface ADXStaggeredGridLayoutManager_AnchorInfo : NSObject {
 @public
  int32_t mPosition_;
  int32_t mOffset_;
  bool mLayoutFromEnd_;
  bool mInvalidateOffsets_;
  bool mValid_;
  IOSIntArray *mSpanReferenceLines_;
}

#pragma mark Package-Private

- (instancetype)initWithADXStaggeredGridLayoutManager:(ADXStaggeredGridLayoutManager *)outer$;

- (void)assignCoordinateFromPadding;

- (void)assignCoordinateFromPaddingWithInt:(int32_t)addedDistance;

- (void)reset;

- (void)saveSpanReferenceLinesWithADXStaggeredGridLayoutManager_SpanArray:(IOSObjectArray *)spans;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXStaggeredGridLayoutManager_AnchorInfo)

J2OBJC_FIELD_SETTER(ADXStaggeredGridLayoutManager_AnchorInfo, mSpanReferenceLines_, IOSIntArray *)

FOUNDATION_EXPORT void ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager_AnchorInfo *self, ADXStaggeredGridLayoutManager *outer$);

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_AnchorInfo *new_ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXStaggeredGridLayoutManager_AnchorInfo *create_ADXStaggeredGridLayoutManager_AnchorInfo_initWithADXStaggeredGridLayoutManager_(ADXStaggeredGridLayoutManager *outer$);

J2OBJC_TYPE_LITERAL_HEADER(ADXStaggeredGridLayoutManager_AnchorInfo)


#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_StaggeredGridLayoutManager")
