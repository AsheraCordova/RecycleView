//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXRecyclerView\src\main\java\androidx\recyclerview\widget\LayoutState.java
//

#import <Foundation/Foundation.h>
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_LayoutState")
#ifdef RESTRICT_LayoutState
#define INCLUDE_ALL_LayoutState 0
#else
#define INCLUDE_ALL_LayoutState 1
#endif
#undef RESTRICT_LayoutState

#if !defined (ADXLayoutState_) && (INCLUDE_ALL_LayoutState || defined(INCLUDE_ADXLayoutState))
#define ADXLayoutState_

@class ADView;
@class ADXRecyclerView_Recycler;
@class ADXRecyclerView_State;
@class JavaLangBoolean;
@class JavaLangInteger;
@class NSString;

/*!
 @brief Helper class that keeps temporary state while {LayoutManager} is filling out the empty
  space.
 */
@interface ADXLayoutState : NSObject {
 @public
  /*!
   @brief We may not want to recycle children in some cases (e.g.layout)
   */
  bool mRecycle_;
  /*!
   @brief Number of pixels that we should fill, in the layout direction.
   */
  int32_t mAvailable_;
  /*!
   @brief Current position on the adapter to get the next item.
   */
  int32_t mCurrentPosition_;
  /*!
   @brief Defines the direction in which the data adapter is traversed.
   Should be <code>ITEM_DIRECTION_HEAD</code> or <code>ITEM_DIRECTION_TAIL</code>
   */
  int32_t mItemDirection_;
  /*!
   @brief Defines the direction in which the layout is filled.
   Should be <code>LAYOUT_START</code> or <code>LAYOUT_END</code>
   */
  int32_t mLayoutDirection_;
  /*!
   @brief This is the target pixel closest to the start of the layout that we are trying to fill
   */
  int32_t mStartLine_;
  /*!
   @brief This is the target pixel closest to the end of the layout that we are trying to fill
   */
  int32_t mEndLine_;
  /*!
   @brief If true, layout should stop if a focusable view is added
   */
  bool mStopInFocusable_;
  /*!
   @brief If the content is not wrapped with any value
   */
  bool mInfinite_;
}

#pragma mark Public

- (NSString *)description;

#pragma mark Package-Private

- (instancetype)initPackagePrivate;

/*!
 @return true if there are more items in the data adapter
 */
- (bool)hasMoreWithADXRecyclerView_State:(ADXRecyclerView_State *)state;

/*!
 @brief Gets the view for the next element that we should render.
 Also updates current item index to the next item, based on <code>mItemDirection</code>
 @return The next element that we should render.
 */
- (ADView *)nextWithADXRecyclerView_Recycler:(ADXRecyclerView_Recycler *)recycler;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXLayoutState)

inline int32_t ADXLayoutState_get_LAYOUT_START(void);
#define ADXLayoutState_LAYOUT_START -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLayoutState, LAYOUT_START, int32_t)

inline int32_t ADXLayoutState_get_LAYOUT_END(void);
#define ADXLayoutState_LAYOUT_END 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLayoutState, LAYOUT_END, int32_t)

inline int32_t ADXLayoutState_get_INVALID_LAYOUT(void);
#define ADXLayoutState_INVALID_LAYOUT ((int32_t) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(ADXLayoutState, INVALID_LAYOUT, int32_t)

inline int32_t ADXLayoutState_get_ITEM_DIRECTION_HEAD(void);
#define ADXLayoutState_ITEM_DIRECTION_HEAD -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLayoutState, ITEM_DIRECTION_HEAD, int32_t)

inline int32_t ADXLayoutState_get_ITEM_DIRECTION_TAIL(void);
#define ADXLayoutState_ITEM_DIRECTION_TAIL 1
J2OBJC_STATIC_FIELD_CONSTANT(ADXLayoutState, ITEM_DIRECTION_TAIL, int32_t)

FOUNDATION_EXPORT void ADXLayoutState_initPackagePrivate(ADXLayoutState *self);

FOUNDATION_EXPORT ADXLayoutState *new_ADXLayoutState_initPackagePrivate(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADXLayoutState *create_ADXLayoutState_initPackagePrivate(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXLayoutState)

@compatibility_alias AndroidxRecyclerviewWidgetLayoutState ADXLayoutState;


#endif

#pragma pop_macro("INCLUDE_ALL_LayoutState")
